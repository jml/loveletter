use std::collections::TreeSet;
use std::rand;
use std::rand::Rng;

// XXX: Make a loveletter namespace (figure out how to do this properly).

#[deriving(PartialEq, PartialOrd, Eq, Ord, Show)]
enum Card {
    Soldier,
    Clown,
    Knight,
    Priestess,
    Wizard,
    General,
    Minister,
    Princess,
}


static CARDS_IN_DECK: uint = 16;

// Love Letter is a game for exactly four players.
static NUM_PLAYERS: uint = 4;

static DECK: [Card, ..CARDS_IN_DECK] = [
    Soldier,
    Soldier,
    Soldier,
    Soldier,
    Soldier,
    Clown,
    Clown,
    Knight,
    Knight,
    Priestess,
    Priestess,
    Wizard,
    Wizard,
    General,
    Minister,
    Princess,
    ];


struct Deck([Card, ..CARDS_IN_DECK]);

#[deriving(Show, PartialEq, Eq)]
enum DeckError {
    WrongCards,
    WrongNumber(uint),
}

impl Deck {
    fn shuffle() -> Deck {
        let mut cards = DECK;
        let mut rng = rand::task_rng();
        rng.shuffle(cards);
        Deck(cards)
    }

    fn from_array(cards: [Card, ..CARDS_IN_DECK]) -> Result<Deck, DeckError> {
        if is_valid_deck(cards.as_slice()) {
            Ok(Deck(cards))
        } else {
            Err(WrongCards)
        }
    }

    fn from_slice(cards: &[Card]) -> Result<Deck, DeckError> {
        if cards.len() != CARDS_IN_DECK {
            return Err(WrongNumber(cards.len()));
        }
        // XXX: Is there a way I can do this without needing to explicitly
        // mention any element?
        let card_array: [Card, ..CARDS_IN_DECK] = [
            cards[0],
            cards[1],
            cards[2],
            cards[3],
            cards[4],
            cards[5],
            cards[6],
            cards[7],
            cards[8],
            cards[9],
            cards[10],
            cards[11],
            cards[12],
            cards[13],
            cards[14],
            cards[15],
            ];
        Deck::from_array(card_array)
    }
}

fn is_valid_deck(deck: &[Card]) -> bool {
    // XXX: Probably don't need to collect & sort the full deck here, since
    // it's already sorted. Not sure if there's a way to assert that at
    // compile time.
    let mut full_deck: Vec<&Card> = DECK.iter().collect();
    let mut sorted_deck: Vec<&Card> = deck.iter().collect();
    full_deck.sort();
    sorted_deck.sort();
    full_deck == sorted_deck
}

// Game state:
// - discarded card
// - the remaining deck
// - each player's card
// - whether they are protected by priestess
// - each player's discard
//   - publicly available


struct Game {
    _hands: [Card, ..NUM_PLAYERS],
    _burnt: Card,
    _deck: Vec<Card>,
}

// XXX: Next time, remind me not to take the alcohol when they offer it.

impl Game {
    fn new() -> Game {
        let Deck(cards) = Deck::shuffle();
        // XXX: How do we say that we're not going to mutate a variable any more?
        // After this point, we don't want to mutate 'cards'.
        //
        // XXX: Is there a better syntax for this? (Problem is duplicating
        // NUM_PLAYERS implicitly by explicitly listing cards.)
        let hands: [Card, ..NUM_PLAYERS] = [
            cards[0],
            cards[1],
            cards[2],
            cards[3],
            ];
        let burn = cards[NUM_PLAYERS];
        Game {
            _hands: hands,
            _burnt: burn,
            _deck: cards.slice_from(5).iter().map(|&x| x).collect(),
        }
    }

    fn burn_card(&self) -> Card {
        self._burnt
    }

    fn hands(&self) -> &[Card] {
        self._hands
    }

    fn deck(&self) -> &[Card] {
        self._deck.as_slice()
    }

    fn num_cards_remaining(&self) -> uint {
        self._deck.len()
    }
}


#[test]
fn test_card_ordering() {
    assert!(Soldier <= Soldier);
    assert!(Soldier < Clown);
    assert!(Soldier < Princess);
}


#[test]
fn test_new_game() {
    // make a new game, make sure that the number & kinds of cards matches the
    // rules (5 soldiers, 2 clowns, etc.)
    let g = Game::new();
    assert_eq!(11, g.num_cards_remaining())
}

#[test]
fn test_cards_remaining() {
    // XXX: INVARIANT: It is always the case that the remaining deck is a
    // subset of the total deck.
    let g = Game::new();
    let full_deck: TreeSet<Card> = DECK.iter().map(|&x| x).collect();
    let deck: TreeSet<Card> = g.deck().iter().map(|&x| x).collect();
    assert!(full_deck.is_superset(&deck));
}

#[test]
fn test_all_cards_in_game() {
    // make a new game, make sure that the number & kinds of cards matches the
    // rules (5 soldiers, 2 clowns, etc.)
    let g = Game::new();
    let mut full_deck: Vec<&Card> = DECK.iter().collect();
    full_deck.sort();
    let mut found_cards: Vec<&Card> = g.deck().iter().collect();
    let burnt = g.burn_card();
    found_cards.push(&burnt);
    for card in g.hands().iter() {
        found_cards.push(card);
    }
    // XXX: You don't want to test set equality, because that'll eliminate
    // duplicates.
    found_cards.sort();
    assert_eq!(full_deck, found_cards);
}


#[test]
fn test_deck_shuffle() {
    let Deck(mut cards) = Deck::shuffle();
    cards.sort();
    assert_eq!(DECK.as_slice(), cards.as_slice());
}

#[test]
fn test_deck_fixed_good() {
    match Deck::from_array(DECK) {
        Ok(Deck(cards)) => assert_eq!(cards.as_slice(), DECK.as_slice()),
        Err(e) => fail!("Unexpected error: {}", e),
    }
}

#[test]
fn test_deck_fixed_too_many_soldiers() {
    let cards = [
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        ];
    match Deck::from_array(cards) {
        Ok(Deck(cards)) => fail!("Should not have been OK: {}", cards.as_slice()),
        Err(error) => assert_eq!(error, WrongCards),
    }
}

#[test]
fn test_deck_variable_good() {
    match Deck::from_slice(DECK.as_slice()) {
        Ok(Deck(cards)) => assert_eq!(cards.as_slice(), DECK.as_slice()),
        Err(e) => fail!("Unexpected error: {}", e),
    }
}

#[test]
fn test_deck_variable_too_few() {
    let cards = [Soldier];
    match Deck::from_slice(cards.as_slice()) {
        Ok(Deck(cards)) => fail!("Should not have been OK: {}", cards.as_slice()),
        Err(error) => assert_eq!(error, WrongNumber(cards.len())),
    }
}

#[test]
fn test_deck_variable_too_many() {
    // One soldier too many
    let cards = [
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Soldier,
        Clown,
        Clown,
        Knight,
        Knight,
        Priestess,
        Priestess,
        Wizard,
        Wizard,
        General,
        Minister,
        Princess,
        ];
    match Deck::from_slice(cards.as_slice()) {
        Ok(Deck(cards)) => fail!("Should not have been OK: {}", cards.as_slice()),
        Err(error) => assert_eq!(error, WrongNumber(cards.len())),
    }
}

// XXX: Probably want a method to make a game from an already-shuffled deck
// Once we've got that, we can start testing adjudication.

